{
  parserClass='org.ziglang.ZigParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Zig'
  psiImplClassSuffix='Impl'
  psiPackage='org.ziglang.psi'
  psiImplPackage='org.ziglang.psi.impl'

  extends('.*Expr')=expr

  tokenTypeClass='org.ziglang.ZigTokenType'
  elementTypeHolderClass='org.ziglang.psi.ZigTypes'
  elementTypeClass='org.ziglang.ZigElementType'
}

zigFile ::= containerMembers

containerMembers ::=
    ( testDecl
    | topLevelComptime
    | topLevelDecl
    )* ((containerField COMMA)* containerField)?

testDecl ::= TEST_KEYWORD stringLiteralSimple block {
    methods = [
        testName="stringLiteralSimple"
    ]
}

topLevelComptime ::= COMPTIME_KEYWORD block

private topLevelDecl ::= ( // TopLevelDecl
      globalFnPrototype
    | globalFnDeclaration
    | globalVarDeclaration
    | globalUsingNamespace
    )

globalFnPrototype ::= PUB_KEYWORD? (EXPORT_KEYWORD | EXTERN_KEYWORD stringLiteralSimple? | INLINE_KEYWORD)? fnProto SEMICOLON {
    methods=[
        functionPrototype="fnProto"
        extern="stringLiteralSimple"
    ]
}
globalFnDeclaration ::= PUB_KEYWORD? (EXPORT_KEYWORD | EXTERN_KEYWORD stringLiteralSimple? | INLINE_KEYWORD)? fnProto block {
    mixin='org.ziglang.psi.impl.ZigFnDeclarationMixin'
    methods=[
        functionPrototype="fnProto"
        extern="stringLiteralSimple"
    ]
}
globalVarDeclaration ::= PUB_KEYWORD? (EXPORT_KEYWORD | EXTERN_KEYWORD stringLiteralSimple?)? THREADLOCAL_KEYWORD? varDecl {
    methods=[
        extern="stringLiteralSimple"
    ]
}
globalUsingNamespace ::= PUB_KEYWORD? USINGNAMESPACE_KEYWORD expr SEMICOLON

fnProto ::= FN_KEYWORD symbol? LPAREN paramDeclList RPAREN byteAlign? linkSection? EXCLAMATIONMARK? (ANYTYPE_KEYWORD | typeExpr) {
    implements=['com.intellij.psi.PsiNameIdentifierOwner']
    mixin='org.ziglang.psi.impl.TrivialDeclaration'
}
private paramDeclList ::= (paramDecl COMMA)* paramDecl?

varDecl ::= (CONST_KEYWORD | VAR_KEYWORD) symbol (COLON typeExpr)? byteAlign? linkSection? (EQUAL expr)? SEMICOLON {
	implements=['com.intellij.psi.PsiNameIdentifierOwner'; 'org.ziglang.psi.impl.IZigVariableDeclaration']
	mixin='org.ziglang.psi.impl.ZigVariableDeclarationMixin'
}

containerField ::= COMPTIME_KEYWORD? symbol (COLON typeExpr)? (EQUAL expr)?

// Block level
statement ::=
      variableDeclarationStatement
    | COMPTIME_KEYWORD blockExprStatement
    | NOSUSPEND_KEYWORD blockExprStatement
    | SUSPEND_KEYWORD (SEMICOLON | blockExprStatement)
    | DEFER_KEYWORD blockExprStatement
    | ERRDEFER_KEYWORD blockExprStatement
    | ifStatement
    | labeledStatement
    | switchExpr
    | assignExpr SEMICOLON {
    pin=1
}

variableDeclarationStatement ::= COMPTIME_KEYWORD? varDecl

ifStatement ::=
      ifPrefix blockExpr (ELSE_KEYWORD payload? statement)?
    | ifPrefix assignExpr (SEMICOLON | ELSE_KEYWORD payload? statement)

labeledStatement ::= blockLabel? (block | loopStatement)

loopStatement ::= INLINE_KEYWORD? (forStatement | whileStatement)

forStatement ::=
      forPrefix blockExpr (ELSE_KEYWORD statement)?
    | forPrefix assignExpr (SEMICOLON | ELSE_KEYWORD statement)

whileStatement ::= blockExpr | assignExpr SEMICOLON

blockExprStatement ::= blockExpr | assignExpr SEMICOLON

blockExpr ::= blockLabel? block

// Expression level
assignExpr ::= expr (assignOp expr)?
expr ::= TRY_KEYWORD* boolOrExpr
boolOrExpr ::= boolAndExpr (OR_KEYWORD boolAndExpr)*
boolAndExpr ::= compareExpr (AND_KEYWORD compareExpr)*
compareExpr ::= bitwiseExpr (compareOp bitwiseExpr)?
bitwiseExpr ::= bitShiftExpr (bitwiseOp bitShiftExpr)*
bitShiftExpr ::= additionExpr (bitShiftOp additionExpr)*
additionExpr ::= multiplyExpr (additionOp multiplyExpr)*
multiplyExpr ::= prefixExpr (multiplyOp prefixExpr)*
prefixExpr ::= prefixOp* primaryExpr
// Primary expression which may not appear as a type
primaryExpr ::=
      asmExpr
    | ifExpr
    | BREAK_KEYWORD breakLabel? expr?
    | COMPTIME_KEYWORD expr
    | NOSUSPEND_KEYWORD expr
    | CONTINUE_KEYWORD breakLabel?
    | RESUME_KEYWORD expr
    | RETURN_KEYWORD expr?
    | blockLabel? loopExpr
    | block
    | curlySuffixExpr

ifExpr ::= ifPrefix expr (ELSE_KEYWORD payload? expr)?

block ::= LBRACE statement* RBRACE {
    mixin='org.ziglang.psi.impl.ZigBlockMixin'
}

loopExpr ::= INLINE_KEYWORD? (forExpr | whileExpr)

forExpr ::= forPrefix expr (ELSE_KEYWORD expr)?

whileExpr ::= whilePrefix expr (ELSE_KEYWORD payload? expr)?

curlySuffixExpr ::= typeExpr initList?

initList ::=
      LBRACE fieldInit (COMMA fieldInit)* COMMA? RBRACE
    | LBRACE expr (COMMA expr)* COMMA? RBRACE
    | LBRACE RBRACE

// Expression which may appear as a type (but does not have to represent a type)
typeExpr ::= prefixTypeOp* errorUnionExpr

errorUnionExpr ::= suffixExpr (EXCLAMATIONMARK typeExpr)?

suffixExpr ::=
      ASYNC_KEYWORD primaryTypeExpr suffixOp* fnCallArguments
    | primaryTypeExpr (suffixOp | fnCallArguments)*

// Primary expression which may appear as a type
primaryTypeExpr ::=
      primaryBuiltinExpr
    | primaryCharExpr
    | containerDecl
    | DOT symbol
    | DOT initList
    | errorSetDecl
    | primaryFloatExpr
    | fnProto
    | groupedExpr
    | labeledTypeExpr
    | symbol // may represent a variable, a type, maybe even something else
    | ifTypeExpr
    | primaryIntExpr
    | COMPTIME_KEYWORD typeExpr
    | ERROR_KEYWORD DOT symbol
    | primaryBoolExpr
    | primaryNullExpr
    | primaryKeywordExpr
    | stringLiteral
    | switchExpr

primaryBuiltinExpr ::= BUILTIN_IDENTIFIER fnCallArguments {
    methods=[
        builtin="BUILTIN_IDENTIFIER";
        arguments="fnCallArguments"
    ]
}
primaryIntExpr     ::= INTEGER_LITERAL
primaryFloatExpr   ::= FLOAT_LITERAL
primaryBoolExpr    ::= TRUE_KEYWORD | FALSE_KEYWORD
primaryNullExpr    ::= NULL_KEYWORD
primaryCharExpr    ::= CHAR_LITERAL
primaryKeywordExpr ::= UNDEFINED_KEYWORD | UNREACHABLE_KEYWORD | ANYFRAME_KEYWORD

containerDecl ::= (EXTERN_KEYWORD | PACKED_KEYWORD)? containerDeclAuto

errorSetDecl ::= ERROR_KEYWORD LBRACE errorIdentifierList RBRACE { extends=expr }
private errorIdentifierList  ::= (symbol COMMA)* symbol?

groupedExpr ::= LPAREN expr RPAREN

ifTypeExpr ::= ifPrefix typeExpr (ELSE_KEYWORD payload? typeExpr)?

labeledTypeExpr ::=
      blockLabel block
    | blockLabel? loopTypeExpr

loopTypeExpr ::= INLINE_KEYWORD? (forTypeExpr | whileTypeExpr)

forTypeExpr ::= forPrefix typeExpr (ELSE_KEYWORD typeExpr)?

whileTypeExpr ::= whilePrefix typeExpr (ELSE_KEYWORD payload? typeExpr)?

switchExpr ::= SWITCH_KEYWORD LPAREN expr RPAREN LBRACE switchProngList RBRACE
private switchProngList ::= (switchProng COMMA)* switchProng?

// Assembly
asmExpr ::= ASM_KEYWORD VOLATILE_KEYWORD? LPAREN stringLiteral asmOutput? RPAREN

asmOutput ::= COLON asmOutputList asmInput?
private asmOutputList   ::= (asmOutputItem COMMA)* asmOutputItem?
asmOutputItem ::= LBRACKET symbol RBRACKET stringLiteral LPAREN (MINUSRARROW typeExpr | symbol) RPAREN

asmInput ::= COLON asmInputList asmClobbers?
private asmInputList    ::= (asmInputItem COMMA)* asmInputItem?
asmInputItem ::= LBRACKET symbol RBRACKET stringLiteral LPAREN expr RPAREN

asmClobbers ::= COLON asmClobbersList
private asmClobbersList ::= (stringLiteral COMMA)* stringLiteral? //stringsList

// Helper grammar
breakLabel ::= COLON symbol

blockLabel ::= symbol COLON

fieldInit ::= DOT symbol EQUAL expr

whileContinueExpr ::= COLON LPAREN assignExpr RPAREN

linkSection ::= LINKSECTION_KEYWORD LPAREN expr RPAREN

paramDecl ::= (NOALIAS_KEYWORD | COMPTIME_KEYWORD)? (symbol COLON)? paramType {
    implements=['com.intellij.psi.PsiNameIdentifierOwner']
	mixin='org.ziglang.psi.impl.ZigParamDeclarationMixin'
}

paramType ::=
      ANYTYPE_KEYWORD
    | DOT3
    | typeExpr

// Control flow prefixes
ifPrefix ::= IF_KEYWORD LPAREN expr RPAREN ptrPayload? {
    methods=[
        condition="expr"
    ]
}

whilePrefix ::= WHILE_KEYWORD LPAREN expr RPAREN ptrPayload? whileContinueExpr?

forPrefix ::= FOR_KEYWORD LPAREN expr RPAREN ptrIndexPayload

// Payloads
payload ::= PIPE symbol PIPE

ptrPayload ::= PIPE ASTERISK? symbol PIPE

ptrIndexPayload ::= PIPE ASTERISK? symbol (COMMA symbol)? PIPE

// Switch specific
switchProng ::= switchCase EQUALRARROW ptrPayload? assignExpr

switchCase ::=
      switchItem (COMMA switchItem)* COMMA?
    | ELSE_KEYWORD

switchItem ::= expr (DOT3 expr)?

// Operators
assignOp ::= ASTERISKEQUAL
           | SLASHEQUAL
           | PERCENTEQUAL
           | PLUSEQUAL
           | MINUSEQUAL
           | LARROW2EQUAL
           | RARROW2EQUAL
           | AMPERSANDEQUAL
           | CARETEQUAL
           | PIPEEQUAL
           | ASTERISKPERCENTEQUAL
           | PLUSPERCENTEQUAL
           | MINUSPERCENTEQUAL
           | EQUAL

compareOp ::= EQUALEQUAL
            | EXCLAMATIONMARKEQUAL
            | LARROW
            | RARROW
            | LARROWEQUAL
            | RARROWEQUAL

bitwiseOp ::= AMPERSAND
            | CARET
            | PIPE
            | ORELSE_KEYWORD
            | CATCH_KEYWORD payload?

bitShiftOp ::= LARROW2
             | RARROW2

additionOp ::= PLUS
             | MINUS
             | PLUS2
             | PLUSPERCENT
             | MINUSPERCENT

multiplyOp ::= PIPE2
             | ASTERISK
             | SLASH
             | PERCENT
             | ASTERISK2
             | ASTERISKPERCENT

prefixOp ::= EXCLAMATIONMARK
           | MINUS
           | TILDE
           | MINUSPERCENT
           | AMPERSAND
           | TRY_KEYWORD
           | AWAIT_KEYWORD

prefixTypeOp ::= QUESTIONMARK
               | ANYFRAME_KEYWORD MINUSRARROW
               | arrayTypeStart (byteAlign | CONST_KEYWORD | VOLATILE_KEYWORD | ALLOWZERO_KEYWORD)*
               | ptrTypeStart (ALIGN_KEYWORD LPAREN expr (COLON primaryIntExpr COLON primaryIntExpr)? RPAREN | CONST_KEYWORD | VOLATILE_KEYWORD | ALLOWZERO_KEYWORD)*

suffixOp ::= LBRACKET expr (DOT2 expr?)? RBRACKET
           | DOT symbol
           | DOTASTERISK
           | DOTQUESTIONMARK

fnCallArguments  ::= LPAREN exprList RPAREN
private exprList ::= (expr COMMA)* expr?

// Ptr specific
arrayTypeStart ::= LBRACKET expr? RBRACKET

ptrTypeStart ::= ASTERISK
               | ASTERISK2
               | PTRUNKNOWN
               | PTRC

// ContainerDecl specific
containerDeclAuto ::= containerDeclType LBRACE containerMembers RBRACE

containerDeclType ::= (STRUCT_KEYWORD | ENUM_KEYWORD | OPAQUE_KEYWORD) (LPAREN expr RPAREN)?
                    | UNION_KEYWORD (LPAREN (ENUM_KEYWORD (LPAREN expr RPAREN)? | expr) RPAREN)?

// Alignment
byteAlign ::= ALIGN_KEYWORD LPAREN expr RPAREN

// Misc
stringLiteralSimple ::= STRING_LITERAL_SINGLE {
    extends=stringLiteral
}
stringLiteral ::= stringLiteralSimple | LINE_STRING {
    mixin='org.ziglang.psi.impl.ZigStringMixin'
    implements=['com.intellij.psi.PsiLanguageInjectionHost']
}

symbol ::= IDENTIFIER {
    extends=expr
    implements=['org.ziglang.psi.impl.IZigSymbol']
    mixin='org.ziglang.psi.impl.ZigSymbolMixin'
}
